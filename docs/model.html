---
layout: docs
title: "Programming Model - Developer Docs"
subheader: The Joined Node Programming Model
subtitle: Programming Model
subtitle2: Developer Docs
permalink: /docs/model/
---
<p>We've developed Joined Node to allow Recipes to be hyper-flexible, while also following a set programming model. With that in mind, there are three types of recipes you can run.</p>

<h3>Callback</h3>

<p>In the simplest model, you must provide JavaScript code that returns a function which accepts a single argument: <code>a callback</code>.</p>

<p>To show the recipe has completed, you must call the callback with two arguments: an error (or <code>null</code> if no error), and the result.</p>

<div class="window-toolbar">
	<i class="fa fa-circle red"></i>
	<i class="fa fa-circle orange"></i>
	<i class="fa fa-circle green"></i>
	<span>hello.js</span>
</div>	
<pre><code class="hljs javascript">
module.exports = function(callback) {
	callback(null, { hello: 'callback'});
}
</code></pre><br />

<p>When you invoke the <code>callback</code>, either the result value or an error message will be serialized as JSON and sent back to the caller as <content>application/json</content> content type.</p>

<hr />

<h3>Context and Callback</h3>

<p>A slightly more advanced version of the programming model allows you to create a recipe that accepts two arguments: a <code>context</code> and a <code>callback</code>.</p>

<div class="window-toolbar">
	<i class="fa fa-circle red"></i>
	<i class="fa fa-circle orange"></i>
	<i class="fa fa-circle green"></i>
	<span>hello.js</span>
</div>	
<pre><code class="hljs javascript">
module.exports = function(context, callback) {
	callback(null, { hello: context.data.name });
}
</code></pre><br />

<p>The <code>context</code> parameter is a JavaScript object with the following properties:</p>

<p><ol>
	<li><code>context.data</code> is an object that contains parameters passed to the code via <code>GET</code> or <code>POST</code>.</li>
	<li><code>context.env</code> is a object that contains any <a href="/docs/env/">encrypted parameters</a> you've added for this recipe.</li>
	<li><code>context.method</code> is a string variable that tells you what method was used: <code>GET</code> or <code>POST</code>.</li>
	<l><code>context.body</code> is representation of a parsed request body. It is only present for requests with bodies such as a <code>POST</code>.</l>
</ol></p>

<hr />

<h3>Total HTTP control</h3>

<p>This model is the most flexible programming model which allows you to take full control over the HTTP request and response.</p>

<p>Using this model, you pass three arguments:</p>

<p><ol>
	<li><code>context</code>: works the same as above</li>
	<li><code>req</code>: HTTP request object</li>
	<li><code>res</code>: HTTP response object</li>
</ol></p>

<div class="window-toolbar">
	<i class="fa fa-circle red"></i>
	<i class="fa fa-circle orange"></i>
	<i class="fa fa-circle green"></i>
	<span>hello.js</span>
</div>	
<pre><code class="hljs javascript">
module.exports = function (context, req, res) {
	res.writeHead(200, { 'Content-Type': 'text/html '});
	res.end('&lt;h1>Hello, world!&lt;/h1>');
}
</code></pre><br />

<p>One thing to keep in mind is that this programming model does not use a callback, and so ending the HTTP response indicates the recipe has finished.</p>

<hr />
<div class="well">
	<p>In all three models, the order of the argumentss is <strong>very</strong> important</p>
</div>

<p>Our programming model allows for flexibility in building your Joined Node recipes while also sticking to a set model, this helps keep apps streamlined.</p>